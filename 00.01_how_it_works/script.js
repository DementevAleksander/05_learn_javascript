'use strict';

// Контекст выполнения
// Контекст выполнения — это абстрактное понятие окружения, в котором код оценивается и выполняется. Всякий раз, когда какой-либо код выполняется в JavaScript он запускается в контексте выполнения.
// Код функции выполняется внутри контекста выполнения функции, а глобальный код в свою очередь выполняется внутри глобального контекста выполнения. Каждая функция имеет свой собственный контекст выполнения.

// Стек вызовов
// Под стеком вызовов подразумевается стек со структурой LIFO(Last in, First Out/Последний вошел, первый вышел), который используется для хранения всех контекстов выполнения, созданных на протяжении исполнения кода.
// В JavaScript имеется только один стек вызовов, так как это однопоточный язык программирования. Структура LIFO означает, что элементы могут добавляться и удаляться только с вершины стека.

const second = function() {
    console.log('Вторая фраза!');
};
const first = function() {
    console.log('Первая фраза!');
    second();
    console.log('Третья фраза!');
};
first();

// Вывод:
// Первая фраза!
// Вторая фраза!
// Третья фраза!

// Когда код начал выполняться, был создан глобальный контекст выполнения(представленный как main()) и добавлен на вершину стека вызовов. Когда встречается вызов функции first(), он так же добавляется на вершину стека.
// Далее, на вершину стека вызовов помещается console.log('Hi there!'), после выполнения он удаляется из стека. После этого мы вызываем функцию second(), поэтому она помещается на вершину стека.
// console.log('Hello there!') добавлен на вершину стека и удаляется из него по завершению выполнения. Функция second() завершена, она также удаляется из стека.
// console.log('The End') добавлен на вершину стека и удален по завершению. После этого функция first() завершается и также удаляется из стека.
// Выполнение программы заканчивается, поэтому глобальный контекст вызова(main()) удаляется из стека.

// -------------------------------------------------------------------//
// Что такое блокирование?
// Давайте предположим, что мы выполняем обработку изображения или сетевой запрос синхронно. Например:
const processImage = (image) => {
    /**    * Выполняем обработку изображения    **/
    console.log('Картинка обработана!');
  };
const networkRequest = (url) => {
/**    * Обращаемся к некоторому сетевому ресурсу    **/
    return console.log('Возвращаем какие-нибудь данные. Данные получены!');
};
const greeting = () => {
    console.log('Hello, World!');
};
processImage('logo.jpg');
networkRequest('www.somerandomurl.com');
greeting();

//Вывод:
// Картинка обработана!
// Возвращаем какие-нибудь данные. Данные получены!
// Hello, World!

// Обработка изображения и сетевой запрос требует времени. Когда функция processImage() вызвана её выполнение потребует некоторого времени, в зависимости от размера изображения.
// Когда функция processImage() выполнена она удаляется из стека. После нее вызывается и добавляется в стек функция networkRequest(). Это снова займет некоторое время прежде чем завершить выполнение.
// В конце концов, когда функция networkRequest() выполнена, вызывается функция greeting(), поскольку она содержит только метод console.log, а этот метод, как правило, выполняется быстро, функция greeting() выполнится и завершится мгновенно.
// Как вы видите, нам нужно ждать пока функция(такие как processImage() или networkRequest()) завершится. Это означает, что такие функции блокируют стек вызовов или основной поток. По итогу мы не можем выполнить другие операции, пока код выше не будет выполнен.

// Так какое же решение?
// Самое простое решение — это асинхронные функции обратного вызова. Мы используем их, чтобы сделать наш код неблокируемым. Например:
const networkRequestNew = () => {
    setTimeout(() => { //Иммитируем сетевой запрос. setTimeout не является частью движка JavaScript, это часть так называемого web API(в браузере) и C/C++ APIs (в node.js).
      console.log('Асинхронный код!');
    }, 5000);
  };
console.log('Привет мир!');
networkRequestNew();
console.log('The End!');

// Вывод:
// Привет мир!
// The End!
// Асинхронный код!

//Для того чтобы понять, как этот код выполняется, мы должны разобраться с ещё несколькими понятиями, такими как цикл обработки событий и очередь обратных вызовов(также известная как очередь задач или очередь сообщений).
// Когда код приведенный выше загружается в браузер console.log('Hello World') добавляется в стек и удаляется из него по завершению выполнения. Далее встречается вызов функции networkRequest(), он добавляется на вершину стека.
// Следующая вызывается функция setTimeout() и помещается на вершину стека. Функция setTimeout() имеет 2 аргумента: 1) функция обратного вызова и 2) время в миллисекундах.
// setTimeout() запускает таймер на 2 секунды в окружении web API. На этом этапе, setTimeout() завершается и удаляется из стека. После этого, в стек добавляется console.log('The End'), выполняется и удаляется из него по завершению.
// Тем временем таймер истек, теперь обратный вызов добавляется в очередь сообщений. Но обратный вызов не может быть немедленно выполнен, и именно здесь в процесс вступает цикл обработки событий.

// Цикл обработки событий
// Задача цикла обработки событий заключается в том чтобы следить за стеком вызовов и определять пуст он или нет. Если стек вызовов пустой, то цикл обработки событий заглядывает в очередь сообщений, чтобы узнать есть ли обратные вызовы, которые ожидают своего выполнения.
// В нашем случае очередь сообщений содержит один обратный вызов, а стек выполнения пуст. Поэтому цикл обработки событий добавляет обратный вызов на вершину стека.
// После console.log('Async Code') добавляется на вершину стека, выполняется и удаляется из него. На этом моменте обратный вызов выполнен и удален из стека, а программа полностью завершена.

// События DOM
// Очередь сообщений также содержит обратные вызовы от событий DOM, такие как клики и “клавиатурные” события. Например:
document.querySelector('.btn').addEventListener('click',(event) => {
    console.log('Button Clicked');
  });
// В случае с событиями DOM, обработчик событий находится в окружении web API, ожидая определенного события(в данном случае клик), и когда это событие происходит функция обратного вызова помещается в очередь сообщений, ожидая своего выполнения.

// ES6 Очередь микротасков
// ES6 представил понятие очередь микротасков, которые используются “промисами” в JavaScript. Разница между очередью сообщений и очередью микротасков состоит в том, что очередь микротасков имеет более высокий приоритет по сравнению с очередью сообщений, это означает, что “промисы” внутри очереди микротасков будут выполняться раньше, чем обратные вызовы в очереди сообщений.
// Например:
console.log('Скрипт запустился!');
setTimeout(() => {
  console.log('setTimeout!');
}, 0);
new Promise((resolve, reject) => {
    resolve('Promise выполенен!');
  }).then(res => console.log(res))
    .catch(err => console.log(err));
console.log('Скрипт завершён!');

//Вывод:
// Скрипт запустился!
// Скрипт завершён!
// Promise выполенен!
// setTimeout!

// Как вы можете видеть, “промис” выполнился раньше setTimeout, все это из-за того, что ответ “промиса” хранится внутри очереди микростасков, которая имеет более высокий приоритет, нежели очередь сообщений.

// Давайте разберем следующий пример, на этот раз 2 “промиса” и 2 setTimeout:
console.log('Скрипт запустился!');
setTimeout(() => {
  console.log('setTimeout 1');
}, 0);
setTimeout(() => {
  console.log('setTimeout 2');
}, 0);
new Promise((resolve, reject) => {
    resolve('Promise 1 выполенен!');
  }).then(res => console.log(res))
    .catch(err => console.log(err));
new Promise((resolve, reject) => {
    resolve('Promise 2 выполенен!');
  }).then(res => console.log(res))
    .catch(err => console.log(err));
console.log('Скрипт завершён!');

// Вывод:
// Скрипт запустился!
// Скрипт завершён!
// Promise 1 выполенен!
// Promise 2 выполенен!
// setTimeout 1
// setTimeout 2

// И снова оба наших “промиса” выполнились раньше обратных вызовов внутри setTimeout, так как цикл обработки событий считает задачи из очереди микротасков важнее задач из очереди сообщений/очереди задач.

// Если во время выполнения задач из очереди микротасков появляется ещё один “промис”, то он будет добавлен в конец этой очереди и выполнен раньше обратных вызовов из очереди сообщений, и не важно сколько времени они ожидают своего выполнения.
console.log('Скрипт запустился!');
setTimeout(() => {
  console.log('setTimeout');
}, 0);
new Promise((resolve, reject) => {
    resolve('Promise 1 выполенен!');
  }).then(res => console.log(res));
new Promise((resolve, reject) => {
  resolve('Promise 2 выполенен!');
  }).then(res => {
       console.log(res);
       return new Promise((resolve, reject) => {
         resolve('Promise 3 выполенен!');
       });
     }).then(res => console.log(res));
console.log('Скрипт завершён!');

// Вывод:
// Скрипт запустился!
// Скрипт завершён!
// Promise 1 выполенен!
// Promise 2 выполенен!
// Promise 3 выполенен!
// setTimeout

// Таким образом, все задачи из очереди микротасков будут выполнены раньше задач из очереди сообщений. То есть цикл обработки событий сначала очистит очередь микротасков, а только после этого начнет выполнение обратных вызовов из очереди сообщений.

// Итак, мы изучили, как работает асинхронный JavaScript и понятия: стека вызовов, цикла обработки событий, очереди сообщений/очереди задач и очереди микротасков, которые составляют среду выполнения JavaScript

const objAvto = {
    color: 'red',
    height: 120,
    speed: 320,
    km: 150000,
    methodObjAvto: function (params) {
        console.log(params);
    }
};
console.log(objAvto);
console.log(objAvto.km);
objAvto.methodObjAvto('Сейчас вылетит аргумент!');

console.log();