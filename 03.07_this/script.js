'use strict';
// this - контекст вызова.
function showThis(a, b) {
      console.log(this);
      function sum() {
            console.log(this);
            return a + b;
      }
      console.log(sum());
}
showThis(4, 5);
// Вывод: Обычная функция this=window, но если стоит use strict, то будет undefined.

const obj = {
      a: 20,
      b: 15,
      sum: function () {
            console.log(this);
      }
};
obj.sum();
//Вывод: Контекст у методов объекта - сам объект.

const obj1 = {
      a: 20,
      b: 15,
      sum: function () {
            function shout() {
                  console.log(this);   
            }
            shout();
      }
};
obj1.sum();
// Вывод: undefined - простой вызов функции, он уже не относится к методу, это не метод объекта. Это функция, которая запускается внутри метода. Поэтому контекст вызова просто потерян. По сути ситуация аналогична первой ситуации.

function User(name, id) { //Для каждого конкретного пользователя будем указывать уникальные имя и номер. Это функция конструктор, когда она будет вызываться, то будет создавать объект.
      this.name = name; //Свойсва, которые обращаются к this.
      this.id = id;
      this.human = true; //все пользователи - люди.
      //такая функция стала конструктором. С её помощью можно создать новых пользователей.
      //кроме свойств можно записать методы.
      this.hello = function () {
            console.log(`Hello, ${this.name}`); //можно использовать свойства, которые находятся в этом же объекте.
      };
}
const ivan = new User('Ivan', 28); //new содаёт новый объект с теми свойствами, которые мы задали. This всегда ссылается на экземпляр new. Когда мы создаём новый объект, мы создаём новое свойство.
//Вывод: this в конструкторах и классах - это новый экземпляр объекта.

function sayName(surname) {
      console.log(this);
      console.log(this.name + surname);
}
const user = {
      name: 'John'
};
sayName.call(user, ' Smith, Мудрец'); //Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами.
sayName.apply(user, [' Smith, Мудрец']); //Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта).
//Функция удваивания.
function count(num) {
      return this*num;
}
const double = count.bind(2); //Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение.
// В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
console.log(double(23));
console.log(double(3));


//----------------------- Итог --------------------------//
// 1. Обычная функция this=window, но если стоит use strict, то будет undefined.
// 2. Контекст у методов объекта - сам объект.
// 3. this в конструкторах и классах - это новый экземпляр объекта.
// 4. Ручное присвоение this: call, apply, bind.
// Если стрелочная функция, то this теряется и будет undefined (если не указан родительский объект или функция), если обычная функция, то мы имеем доступ к this, то элемент, на котором происходит событие, то же, что и event.target.

//Пример.
const btn = document.querySelector('button');
btn.addEventListener('click', function() {
      console.log(this); //контекст вызова сам элемент, на котором произошло событие. Так работае в том случае, если функция написана в обычном виде. Но со стрелочной функцией работает не так.
      this.style.backgroundColor = 'red'; // В данном случае this, то же самое, что и event.target. Но чаще в практике используется событие, а не контекст вызова.
      // Если эту функцию поменять на стрелочную, то результатом будет undefined, то есть контекст вызова не найден, теряется.
});

//Стрелочные функции. У стреочной функции нет своего контекста вызова. Она его всегда будет брать у своего родителя.
const obj2 = {
      num: 5,
      sayNamber: function () { //Метод внутри объекта ссылается на сам объект.
            const say = () => {
                  console.log(this); //родителем функции является метод, называемый sayNamber(). У метода контест всегда ссылется на объект, в котором он существует. Поэтому this будет ссылаться на сам объект, так как родитель берёт контекст родителя.
                  // Если записать console.log(this.num); то получип 5. Но если переделать стрелочную функцию в обычную, то уже будет ошибка.
            };
            say();
      }
};
obj2.sayNamber();
// Синтактические нюансы. Ещё пример.
const double2 = a => a * 2; //Если действия функции помещается в одну строку, то можно стрелочную функцию записать без фигурных скобок, на примере return a * 2;. return подставляется автоматически.
// Ещё аргумент можно писать без круглых скобок, то есть (a) будет a, но если несколько аргументов, то нежно оборачивать в круглые скобки.
console.log(double2(4));
