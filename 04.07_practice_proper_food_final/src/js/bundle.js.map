{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/modules/cacl.js","webpack:///./src/js/modules/cards.js","webpack:///./src/js/modules/forms.js","webpack:///./src/js/modules/modal.js","webpack:///./src/js/modules/slider.js","webpack:///./src/js/modules/tabs.js","webpack:///./src/js/modules/timer.js","webpack:///./src/js/script.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,yBAAyB;;AAEzB;;AAEA,sCAAsC;AACtC,0CAA0C;AAC1C,KAAK,OAAO;AACZ;AACA;AACA;;AAEA,wCAAwC;AACxC,8CAA8C;AAC9C,KAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D,wCAAwC;AACxC,mBAAmB;AACnB;AACA,+BAA+B;AAC/B,6GAA6G;AAC7G;AACA,SAAS,OAAO;AAChB,8GAA8G;AAC9G;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;;AAE7D,kCAAkC;AAClC,+CAA+C;AAC/C,0EAA0E;AAC1E,gDAAgD;AAChD;AACA,oFAAoF;AACpF,gDAAgD;AAChD;AACA,SAAS;AACT;AACA,wEAAwE;AACxE,yFAAyF;;AAEzF;AACA,0DAA0D;AAC1D,6DAA6D;;AAE7D,kCAAkC;AAClC,mDAAmD;AACnD,0DAA0D;AAC1D;AACA,iEAAiE;AACjE,wFAAwF;AACxF,iBAAiB;AACjB,sDAAsD;AACtD,6EAA6E;AAC7E;;AAEA,0CAA0C;AAC1C,uDAAuD;AACvD,iBAAiB;;AAEjB,oDAAoD;;AAEpD;AACA,aAAa;AACb,SAAS;AACT;AACA,2EAA2E;AAC3E,4FAA4F;;AAE5F;AACA,8C;AACA,uDAAuD;;AAEvD,+CAA+C;AAC/C,2CAA2C;AAC3C,qDAAqD;AACrD,aAAa;AACb,4CAA4C;AAC5C;AACA,8CAA8C;AAC9C;AACA,0CAA0C;AAC1C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,sB;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iEAAiE;AACjE,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,4CAA4C;AAC5C,oDAAoD;AACpD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS,OAAO,SAAS;AACpD,kDAAkD,WAAW;AAC7D,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA,+CAA+C,IAAI,YAAY,WAAW;AAC1E;AACA,gC;AACA,M;;AAEA;AACA;AACA,uBAAuB,iCAAiC,MAAM;AAC9D,wFAAwF;AACxF,SAAS;AACT,KAAK;;AAEL;AACA;AACA,mCAAmC,iCAAiC,MAAM;AAC1E,+FAA+F;AAC/F,gBAAgB,E;AAChB,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA,0BAA0B,iCAAiC;AAC3D;;AAEA;;AAEA;AACA,8BAA8B,IAAI,OAAO,OAAO;AAChD,qDAAqD,MAAM;AAC3D,mDAAmD,MAAM;AACzD;AACA;AACA;AACA,6DAA6D,MAAM;AACnE;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,2CAA2C;AAC3C,oCAAoC;AACpC;AACA;AACA;AACA,sBAAsB;AACtB;AACA,aAAa;AACb;AACA,SAAS,E;AACT;AACA,gCAAgC;AAChC;AACA;;;;AAIA,iCAAiC;AACjC,gDAAgD;AAChD,+BAA+B;AAC/B;AACA,8D;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,kEAAkE;;AAElE;AACA,gDAAgD,qDAAqD;;AAErG,yBAAyB;AACzB;AACA;;AAEA;AACA,gFAAgF;;AAEhF;AACA;AACA,kCAAkC;AAClC;AACA,iDAAiD;AACjD,wCAAwC;AACxC;AACA;AACA,kDAAkD;AAClD,4BAA4B;AAC5B,8BAA8B,EAAE;AAChC,SAAS;AACT;;AAEA;AACA,uCAAuC;AACvC;;AAEA,8CAA8C;AAC9C,oBAAoB,8EAA8E;;AAElG;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,8BAA8B;AAC9B;AACA,SAAS;AACT,kBAAkB;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,iBAAiB,EAAE,GAAG,EAAE,GAAG,EAAE;AAC7B,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/script.js\");\n","function calc() {\r\n    // Калькулятор калорий.\r\n    const result = document.querySelector('.calculating__result span'); //Основной элемент, куда записывается результат вычислений (итоговое значение ккал).\r\n    // let sex = 'female', //пол. Устанавливаем значение по умолчанию. Чтобы не приходилось нажимать на активный элемент.\r\n    //     height, weight, age, //рост, вес, возраст.\r\n    //     ratio = 1.375; //коэффициент активности. Устанавливаем значение по умолчанию.\r\n\r\n    let sex, height, weight, age, ratio;\r\n\r\n    if (localStorage.getItem('sex')) { //Если в локальном хранилище есть ключ sex\r\n        sex = localStorage.getItem('sex'); //то в переменную sex записываем значение ключа sex из локального хранилища.\r\n    } else { //Иначе устанавливаем значения по умолчанию.\r\n        sex = 'female';\r\n        localStorage.setItem('sex', 'female');\r\n    }\r\n\r\n    if (localStorage.getItem('ratio')) { //Если в локальном хранилище есть ключ ratio\r\n        ratio = localStorage.getItem('ratio'); //то в переменную ratio записываем значение ключа ratio из локального хранилища.\r\n    } else { //Иначе устанавливаем значения по умолчанию.\r\n        ratio = 1.375;\r\n        localStorage.setItem('ratio', 1.375);\r\n    }\r\n\r\n    //Функция подсчёта по формуле вычисления каллорий\r\n    function calcTotal() {\r\n        if (!sex || !height || !weight || !age || !ratio) { //Если не заполнено поля каким-нибудь значением\r\n            result.textContent = '____'; // То выводим сообщение.\r\n            return; //Это необходимо, чтобы прервать функцию.\r\n        }\r\n        if (sex === 'female') { //Если пол женский, то считаем по формуле.\r\n            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio); //BMR = 447.6 + (9.2 x вес, кг) + (3.1 х рост, cм) – (4.3 х возраст, лет). И результат умножаем на коэффициент активности ratio.\r\n            // Math.round() - округляем до целого значения.\r\n        } else { //Иначе (мужской).\r\n            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio); //BMR = 88.36 + (13.4 x вес, кг) + (4.8 х рост, см) – (5.7 х возраст, лет). И результат умножаем на коэффициент активности ratio.\r\n        }\r\n    }\r\n    calcTotal();\r\n\r\n    //Устанавливаем классы активности, в зависимаости от сохранённых значений в localStorage.\r\n    function initLocalSettings(selector, activeClass) {\r\n        const elements = document.querySelectorAll(selector); //Элементы с которыми будем работать.\r\n\r\n        elements.forEach(elem => { //Перебираем элементы.\r\n            elem.classList.remove(activeClass); //Чистим класс актвивности. \r\n            if (elem.getAttribute('id') === localStorage.getItem('sex')) { //Если кнопка с id совпадает с значением из localStorage (с ключом sex).\r\n                elem.classList.add(activeClass); //Устанавливаем класс активности на той кнопке, которая нажата.\r\n            }\r\n            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) { //Если кнопка с атрибутом data-ratio совпадает с значением из localStorage (с ключом ratio).\r\n                elem.classList.add(activeClass); //Устанавливаем класс активности на той кнопке, которая нажата.\r\n            }\r\n        });\r\n    }\r\n    initLocalSettings('#gender div', 'calculating__choose-item_active'); // #gender div - элемент с которым работаем. calculating__choose-item_active - класс активности.\r\n    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active'); // .calculating__choose_big div - элемент с которым работаем. calculating__choose-item_active - класс активности.\r\n\r\n    //Получаем данные с элементов (статический контент).\r\n    function getStaticInformation(selector, activeClass) { //функция будет применяться на нескольких элементах, потому требуется parentSelector. Так же требуется класс активности activeClass для окрашивания кнопок, которые были нажаты.\r\n        const elements = document.querySelectorAll(selector); // Получаем все div внутри выбранного элемента.\r\n\r\n        elements.forEach(elem => { //Перебираем все элементы. Используем делегирование событий.\r\n            elem.addEventListener('click', (e) => { //Отслеживаем клики по родительскому элементу.\r\n                if (e.target.getAttribute('data-ratio')) { //Если атрибут data-ratio присутсвует у объекта события. Это нужно, так как не у всех кнопок есть атрибут data-ratio.\r\n                // getAttribute() возвращает значение указанного атрибута элемента. Если элемент не содержит данный атрибут, могут быть возвращены null или \"\" (пустая строка).\r\n                    ratio = +e.target.getAttribute('data-ratio'); //устанавливаем значение ratio в значение, которое взяли у e.target, то есть в значение дата атрибута data-ratio.\r\n                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio')); //Устанавливаем в параметр ratio со тем значением, которое вёл пользователь для поля с атрибутом data-ratio.\r\n                } else {\r\n                    sex = e.target.getAttribute('id'); //Если у элемента нет атрибута data-ratio, то этот впеременную \"пол\" записываем значение id элемента в который щёлкнули.\r\n                    localStorage.setItem('sex', e.target.getAttribute('id')); //Устанавливаем в параметр sex с тем значением, которое вёл пользователь для поля с id.\r\n                }\r\n    \r\n                elements.forEach(elem => { //перебираем все элементы.\r\n                    elem.classList.remove(activeClass); // убираем класс активности.\r\n                });\r\n    \r\n                e.target.classList.add(activeClass); //Добавляем класс активности.\r\n    \r\n                calcTotal();\r\n            });\r\n        });\r\n    }\r\n    getStaticInformation('#gender div', 'calculating__choose-item_active'); //#gender - родительский элемент блока мужчина/женщина. .calculating__choose-item_active - класс активности.\r\n    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active'); //.calculating__choose_big - родительский элемент блока с коэффициентом активности.\r\n\r\n    //Получаем данные с элементов (динамический контент, который вводит пользователь). \r\n    function getDynamicInformation(selector) { \r\n        const input = document.querySelector(selector); //Получаем данные с поля, которые заполнил пользователь.\r\n\r\n        input.addEventListener('input', () => { //отслеживаем, когда пользователь вводит данные.\r\n            if (input.value.match(/\\D/g)) { //Если в поле введено что-то кроме чисел.\r\n                input.style.border = \"1px solid red\"; //Подсвечиваем поле красным цветом.\r\n            } else {\r\n                input.style.border = 'none'; //Если введено число, то не подсвечиваем поле.\r\n            }\r\n            switch(input.getAttribute('id')) { //Проверяем есть ли у элемента атрибут id.\r\n                case \"height\":\r\n                    height = +input.value; //Записываем значение value, которое ввёл пользователь.\r\n                    break; //Останавиваем кейс.\r\n                case \"weight\":\r\n                    weight = +input.value;\r\n                    break;\r\n                case \"age\":\r\n                    age = +input.value;\r\n                    break;\r\n            }\r\n\r\n            calcTotal();\r\n        });\r\n    }\r\n    getDynamicInformation('#height');\r\n    getDynamicInformation('#weight');\r\n    getDynamicInformation('#age');\r\n}\r\n\r\nmodule.exports = calc;","function cards() {\r\n    //------------------------- Классы стандарт ES6. Карточки на сайте. ----------------------//\r\n    // Используем классы для карточек.\r\n    class MenuCard {\r\n        constructor (src, alt, title, descr, price, parentSelector, ...classes) {\r\n            this.src = src;\r\n            this.alt = alt;\r\n            this.title = title;\r\n            this.descr = descr;\r\n            this.price = price;\r\n            this.classes = classes; //массив\r\n            this.parent = document.querySelector(parentSelector); //получаем один элемент. \r\n            this.transfer = 72; //курс валют.\r\n            this.changeToRUB(); //Конвертация валюты.\r\n        }\r\n        //Создаём дополнитеьный метод, который будет заниматься конвертацией валют.\r\n        changeToRUB () {\r\n            this.price = this.price * this.transfer;\r\n        }\r\n        // Ещё один метод для формирования вёрстки. В данном случае render классическое название.\r\n        render (){\r\n            const element = document.createElement('div'); //создаём элемент в JS <div></div>\r\n            if (this.classes.length === 0) {\r\n                this.element = 'menu__item';//перезаписываем массив.\r\n                element.classList.add(this.element); //ставим дефолтный класс\r\n            } else {\r\n            //Обрабатываем массив ...classes, проходимся по каждому элементу, вытаскиваем название класса и подсоединяем его к div.\r\n            this.classes.forEach(className => element.classList.add(className));\r\n            }\r\n            element.innerHTML = // обращаемся к элементу <div></div>. Через innerHTML динамически создаём структуру, указывая меняющиеся элементы.\r\n            `\r\n                <img src=${this.src} alt=${this.alt}>\r\n                <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n                <div class=\"menu__item-descr\">${this.descr}</div>\r\n                <div class=\"menu__item-divider\"></div>\r\n                <div class=\"menu__item-price\">\r\n                    <div class=\"menu__item-cost\">Цена:</div>\r\n                    <div class=\"menu__item-total\"><span>${this.price}</span> руб./день</div>\r\n                </div>\r\n            `;\r\n            //Нужно указать, куда мы будем помещать все эти карточки. Каждый раз, когда будет вызываться MenuCard это родитель может быть абсолютно разным. Для этого создаём в MenuCard дополнительный аргумент parentSelector, то есть передаём именно селектор parentSelector. Соответственно нужно получить элемент со страницы, куда мы будем помещать этот элемент.\r\n            this.parent.append(element); //Помещаем новый элемент внутрь элемента. Метод ParentNode.append добавляет набор объектов Node или DOMString в конец (после последнего потомка) ParentNode. DOMString объекты добавляются как Text.\r\n        }\r\n    }\r\n    //Класс готов. Теперь его можно использовать.\r\n\r\n    const getResource = async (url) => { //Получаем данные с сервера.\r\n        let res = await fetch(url);\r\n        if (!res.ok) {\r\n            throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n        }\r\n        return await res.json(); \r\n    }; \r\n\r\n    getResource('http://localhost:3000/menu')\r\n    .then(data => {\r\n        data.forEach(({img, altimg, title, descr, price}) => { //реструктуризация объекта, вытаскиваем свойства объекта.\r\n            new MenuCard(img, altimg, title, descr, price, \".menu .container\").render(); //.menu .container указываем родителя, куда мы будем всё это пушать.\r\n        });\r\n    });\r\n\r\n    // axios.get('http://localhost:3000/menu')\r\n    //     .then(data => {\r\n    //         data.data.forEach(({img, altimg, title, descr, price}) => { //обращаемся к тем данным, которые получили.\r\n    //             new MenuCard(img, altimg, title, descr, price, \".menu .container\").render(); //.menu .container указываем родителя, куда мы будем всё это пушать.\r\n    //         }); \r\n    //     });\r\n\r\n    //Динамическая вёрстка. Минус в том, что нет шаблонизации. Данный способ подходит в том случае, если нужно один раз сформировать вёрстку.\r\n        // getResource('http://localhost:3000/menu')\r\n    //     .then(data => createCard(data));\r\n\r\n    // function createCard(data) {\r\n    //     data.forEach(({img, altimg, title, descr, price}) => {\r\n    //         const element = document.createElement('div');\r\n\r\n    //         element.classList.add(\"menu__item\");\r\n\r\n    //         element.innerHTML = `\r\n    //             <img src=${img} alt=${altimg}>\r\n    //             <h3 class=\"menu__item-subtitle\">${title}</h3>\r\n    //             <div class=\"menu__item-descr\">${descr}</div>\r\n    //             <div class=\"menu__item-divider\"></div>\r\n    //             <div class=\"menu__item-price\">\r\n    //                 <div class=\"menu__item-cost\">Цена:</div>\r\n    //                 <div class=\"menu__item-total\"><span>${price}</span> грн/день</div>\r\n    //             </div>\r\n    //         `;\r\n    //         document.querySelector(\".menu .container\").append(element);\r\n    //     });\r\n    // }\r\n\r\n\r\n    //Создаём новый объект и вызываем метод render().\r\n    // const div = new MenuCard();\r\n    // div.render();\r\n    // Альтернативный сбособ создания объекта. Используется только тогда, когда объект создаётся в одном месте и затем на него нет ссылок. В других сллучаях нужно использовать переменную, чтобы объект не потерялся.\r\n    // new MenuCard(\r\n    //     \"img/tabs/vegy.jpg\", //Рекуомндуется/чаще всего используются двойные кавычки.\r\n    //     \"vegy\",\r\n    //     'Меню \"Фитнес\"', //Если двойные кавычки есть в тексте, тогда используем одинарные кавычки.\r\n    //     'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',\r\n    //     9, //долларов. Число трансформируется через метод changeToRUB ().\r\n    //     '.menu .container',\r\n    //     'menu__item',\r\n    //     'big'\r\n    // ).render();\r\n    // // Создаём ещё карточки. Пока что копируем. Но нужно уходить от копипаста и оптимизмровать код.\r\n    // new MenuCard(\r\n    //     \"img/tabs/elite.jpg\", //Рекуомндуется/чаще всего используются двойные кавычки.\r\n    //     \"elite\",\r\n    //     'Меню “Премиум”', //Если двойные кавычки есть в тексте, тогда используем одинарные кавычки.\r\n    //     'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',\r\n    //     14, //долларов. Число трансформируется через метод changeToRUB ().\r\n    //     '.menu .container',\r\n    //     'menu__item',\r\n    //     'big'\r\n    // ).render();\r\n    // new MenuCard(\r\n    //     \"img/tabs/post.jpg\", //Рекуомндуется/чаще всего используются двойные кавычки.\r\n    //     \"post\",\r\n    //     'Меню \"Постное\"', //Если двойные кавычки есть в тексте, тогда используем одинарные кавычки.\r\n    //     'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',\r\n    //     21, //долларов. Число трансформируется через метод changeToRUB ().\r\n    //     '.menu .container',\r\n    //     //'menu__item',\r\n    //     //'big'\r\n    // ).render();\r\n}\r\n\r\nmodule.exports = cards;","function forms() {\r\n    //---------------------- Скрипт отправки данных на сервер. Вариант №2 -------------------------//\r\n    //Современный метод.\r\n    //Задача - взять несколько форм, которые есть на сайте и с них отправлять данные к файлу server.php.\r\n    //Чтобы не создавать два обработчика (так как две формы отпраквки), мы его обернём в функцию.\r\n    const form = document.querySelectorAll('form');    //Получаем все формы по тегу form\r\n    //Пишем функцию, которая отвечает за постинг данных.\r\n    const message = { // Сообщения по итогам обращения к серверу.\r\n        //loading: 'Загрузка',\r\n        loading: 'img/form/spinner.svg', //Исползуем спиннер.\r\n        success: 'Спасибо! Мы свяжемся с вами в ближайшее время!',\r\n        failure: 'Что-то пошло не так! Поломалося!',\r\n    };\r\n\r\n    //Берём все формы и под каждую из них подвязываем bindPostData().\r\n    form.forEach(item => {\r\n        bindPostData(item);\r\n    });\r\n    \r\n    //пишем функцию postData, которая обрабатывает запрос к серверу, fetch'ит.\r\n    //Получаем ответ от сервера, например, что запостили успешно. После этого трансформирует ответ в JSON-формат.\r\n    const postData = async (url, data) => { // postData - отвечает за постинг данных на сервер. async - внутри функции будет асинхронный код, для async необходимо использовать парный оператор await, await ставим перед теми операциями, которые нужно дождаться. async и await всегда используются вместе.\r\n        let res = await fetch(url, { // fetch - запрос. Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch(), который позволяет легко и логично получать ресурсы по сети асинхронно. Подобная функциональность ранее достигалась с помощью XMLHttpRequest.\r\n        // await - сначала ждёт пока запрос будет отправлен на сервер и только когда получили ответ от сервера записываются данные в переменную res.\r\n            //Задаём настройки - метод и body (которое отправляем).\r\n            method: 'POST',\r\n            headers: { //Заголовки, какой контент мы отправляем.\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: data //данные формы.\r\n        }); \r\n        //Обрабатываем JSON-формат.\r\n        return await res.json(); //Обозначение объектов JavaScript (JSON - JavaScript Object Notation) - стандартный текстовый формат для представления структурированных данных на основе синтаксиса объекта JavaScript. Он обычно используется для передачи данных в веб-приложениях (например, отправка некоторых данных с сервера клиенту,таким образом чтобы это могло отображаться на веб-странице или наоборот).\r\n        // await - дожидаемся окончания работы промисса json() и только после этого он его возвращает из функции.\r\n    };\r\n\r\n    \r\n\r\n    function bindPostData(form) { // bindPostData - привязка постинга, то есть привязать какой-то постинг данных.\r\n        form.addEventListener('submit', (e) => { //Отслеживаем отправку данных. Нажатие кнопки.\r\n            e.preventDefault(); //отменяем стандартное поведение браузера.\r\n            //Динамически создаём новый блок для сообщения, который добавляется к форме.\r\n            let statusMessage = document.createElement('img'); \r\n            statusMessage.src = message.loading; //спиннер 'img/form/spinner.svg' вместо текста div\r\n            statusMessage.style.cssText = //В img записали стили. Правильнее помещать в CSS.\r\n            ` \r\n                display: block;\r\n                margin: 0 auto;\r\n            `;\r\n            form.insertAdjacentElement('afterend', statusMessage); //'afterend' - Куда вставляем (после формы), statusMessage - что вставляем.\r\n\r\n            //Отправляем данные на сервер.\r\n            const formData = new FormData(form); //собираем данные из document.querySelector('form');. Создаём объект, в котором будут введённые данные.\r\n\r\n            const obj = {a: 23, b: 50};\r\n            console.log(Object.entries(obj));\r\n            // Вывод в консоль [ [ 'a', 23 ], [ 'b', 50 ] ]\r\n            \r\n            //Трансформируем formData в JSON формат.\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries())); // .entries() - получаем данные с формы в формате массива. .fromEntries() - Превращаем массив в объект. Затем объект превращаем в JSON-формат.\r\n\r\n            postData('http://localhost:3000/requests', json)\r\n            .then(data => {\r\n                console.log(data); //При полоительном результате выводим объект с данными в консоль.\r\n                console.log(message.success);\r\n                showThanksModal(message.success); //Запускаем функцию с сообщением, что всё ОК. Показывается модальное окно и через 4 чекунды оно закрывается, вместе с тексом и возвращением изначального контента, который там был.\r\n                statusMessage.remove();}) //Удаляем спиннер.\r\n            .catch(() => {\r\n                console.log(message.failure);\r\n                showThanksModal(message.failure);}) //При отрицательном запросе к БД выдаём сообщение об ошибке. Если promise попадает на ошибку протокла, то он не выдаст reject, для него это не считается ошибкой, он нормально выполнит при этом resolve. Главное для fetcha - ээто то, что он вообще смог выполнить запрос. reject будет возникать только при сбое сети или что-то там запросу вообще выполниться.\r\n            .finally(() => { //При любом исходе.\r\n                form.reset();}); //Очищаем форму.\r\n        });\r\n    }\r\n\r\n    //---------------------- Улучшаем форму отправки данных на сервер -------------------------//\r\n    function showThanksModal(message) { //message - соообщение, которое будет отправляться пользователю.\r\n        const prevModalDialog = document.querySelector('.modal__dialog');\r\n\r\n        prevModalDialog.classList.add('hide'); //Скрываем .modal__dialog добавлением класса .hide.\r\n        openModal(); //Функция описана выше. Открывает модальное окно modal.classList.add('show'); modal.classList.remove('hide');\r\n\r\n        const thanksModal = document.createElement('div');\r\n        thanksModal.classList.add('modal__dialog'); //Для div добавляем класс modal__dialog.\r\n        thanksModal.innerHTML = //формируем вёрстку.\r\n        `\r\n            <div class=\"modal__content\">\r\n                <div class=\"modal__close\" data-close>×</div>\r\n                <div class=\"modal__title\">${message}</div>\r\n            </div>\r\n        `;\r\n        document.querySelector('.modal').append(thanksModal); //получаем модальное окно и аппендим туда наш блок.\r\n        //Если пользователь захочет снова открыть модальное окно, тогда всё должно возвращаться на свои места. Новый блок исчезал, а старый возвращался на место.\r\n        setTimeout(() => {\r\n            thanksModal.remove(); //через 4 секунды удаляем div с классом modal__dialog.\r\n            prevModalDialog.classList.add('show');\r\n            prevModalDialog.classList.remove('hide');\r\n            closeModal();\r\n        }, 4000);\r\n    }\r\n\r\n    //---------------------- FetchAPi -------------------------//\r\n    //Новая технология обращения к БД, которая сейчас много где используется.\r\n    //Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch(), который позволяет легко и логично получать ресурсы по сети асинхронно.\r\n    //Подобная функциональность ранее достигалась с помощью XMLHttpRequest. Fetch представляет собой лучшую альтернативу, которая может быть легко использована другими технологиями, такими как Service Workers. Fetch также обеспечивает единое логическое место для определения других связанных с HTTP понятий, такие как CORS и расширения для HTTP.\r\n    // Fetch API встроена в браузер и работает на Promise.\r\n    //API - интерфейс програмного обеспечения или приложения. Набор данных и возможностей, которыо епредоставляет нам какое-то решение.\r\n    //Например, DOM API - различне методы, позволяющие работать с элементами на странице.\r\n    // https://jsonplaceholder.typicode.com/ - небольшая база данные в формате JSON, к которой можно обращаться и тестировать ресурсы.\r\n    /*\r\n    //fetch();\r\n    fetch('https://jsonplaceholder.typicode.com/todos', { //делаем запрос к todos (url). Из этой конструкции возвращаеются promise.\r\n        //Задаём настройки - метод и body (которое отправляем).\r\n        method: \"POST\",\r\n        body: JSON.stringify({ //Отправляем JSON данные.\r\n            name: 'Alex'\r\n        }),\r\n        headers: { //Заголовки, какой контент мы отправляем.\r\n            'Content-type': 'application/json'\r\n        }\r\n    }) \r\n    .then(response => response.json()) //Получаем ответ в формате JSON. response.json() - превращает полученные данные в формат объекта javascript, но response.json() возвращает promise.\r\n    .then(json => console.log(json));\r\n    */\r\n\r\n    //Обращаемся к локальной БД.\r\n    fetch('http://localhost:3000/menu')\r\n        .then(data => data.json()) //Берём объект из сервера и превращаем его в js объект.\r\n        .then(res => console.log(res)); //выведем результат в консоль.\r\n    //Результат. Получены данные для получения карточек меню. Меню - массив, который содержит отдельные объекты. Получаем массив данных. Если бы обращались на прямую к файлу fetch('db.json'), то получали бы объект, так как там объекты.\r\n        // (3) [{…}, {…}, {…}]\r\n        //     0: {img: \"img/tabs/vegy.jpg\", altimg: \"vegy\", title: \"Меню 'Фитнес'\", descr: \"Меню 'Фитнес' - это новый подход к приготовлению б… продукт с оптимальной ценой и высоким качеством!\", price: 9}\r\n        //     1: {img: \"img/tabs/post.jpg\", altimg: \"post\", title: \"Меню 'Постное'\", descr: \"Меню 'Постное' - это тщательный подбор ингредиенто… за счет тофу и импортных вегетарианских стейков.\", price: 14}\r\n        //     2: {img: \"img/tabs/elite.jpg\", altimg: \"elite\", title: \"Меню 'Премиум'\", descr: \"В меню 'Премиум' мы используем не только красивый … фрукты - ресторанное меню без похода в ресторан!\", price: 21}\r\n        //     length: 3\r\n        //     __proto__: Array(0)\r\n\r\n    //Установка локального json-сервера требуется для отправки даннызх на локальный сервер и записи этих данных в файл db.json в раздел requests. То есть требуется поддержка POST запросов.\r\n    //Информация о JSON-сервере https://github.com/typicode/json-server\r\n    //Запуск JSON-сервера. json-server src/db.json\r\n    // npx json-server --watch src/db.json\r\n    // npx json-server --watch db.json --port 3000\r\n}\r\n\r\nmodule.exports = forms;","function modal() {\r\n    //------------------------------ Работа с модальным окном -------------------------//\r\n    // Создаём модальное окно.\r\n    // В HTML для модального окна прописывает атрибут data-modal. Пример, <button data-modal class=\"btn btn_dark\">Связаться с нами</button>.\r\n    // Для закрытия модального окна прописываем дата атрибут data-close. Например, <div data-close class=\"modal__close\">&times;</div>.\r\n    //Создаём две функции. 1 - отвечает за открытие модального окна, 2 - за закрытие.\r\n    const modalTridder = document.querySelectorAll('[data-modal]'),\r\n          modal = document.querySelector('.modal');\r\n          // modalCloseBtn = document.querySelector('[data-close]'); //если обработчики событий создаются динамически, то этот элемент на него уже не повесится. Это одна из причин, почему необходимо использовать делегирование событий. Поправим функционал, чтобы он работал со всеми кнопками, в том числе и крестиком, даже если он формируется динамически.\r\n\r\n    //Если код повторяется, хотя бы два раза, то необходимо ко выносить в отдельную функцию.\r\n    function openModal() {\r\n        modal.classList.add('show');\r\n        modal.classList.remove('hide');\r\n        // Альтернативный вариант с toggle\r\n        // modal.classList.toggle('show');\r\n        document.body.style.overflow = 'hidden'; //Убираем прокрутку сайта.\r\n        clearInterval(modalTimerId); //Если пользователь сам вызвал модальное окно, то оно не будет открываться повторно через заданный промежуток времени.\r\n    }\r\n    \r\n    //Перебираем modalTridder (data-modal).\r\n    modalTridder.forEach(btn => {\r\n        //При нажатии на кнопку button Связаться с нами, открываем модальное окно.\r\n        btn.addEventListener('click', openModal);\r\n    });\r\n\r\n    //Если код повторяется, хотя бы два раза, то необходимо ко выносить в отдельную функцию.\r\n    function closeModal() {\r\n        modal.classList.add('hide');\r\n        modal.classList.remove('show');\r\n        document.body.style.overflow = ''; //Возвращаем прокрутку сайта.\r\n    }\r\n\r\n    //Закрываем модальное окно.\r\n    // modalCloseBtn.addEventListener('click', () => {\r\n    //     closeModal();\r\n    // });\r\n    //Правильный вариант написания закрытя модального окна.\r\n    // modalCloseBtn.addEventListener('click', closeModal);\r\n\r\n    //Закрываем моддальное окно по нажатию не только на крестик, но и на подложку.\r\n    modal.addEventListener('click', (e) => {\r\n        if (e.target === modal || e.target.getAttribute('data-close') == '') { //Свойство target интерфейса Event является ссылкой на объект, который был инициатором события или e.target это крестик модального окна, если он присутсвует, то мы будем закрывать модальное окно.\r\n            closeModal();\r\n        }\r\n    });\r\n\r\n    //Закрываем модальное окно по нажатию Esc на клавиатуре.\r\n    document.addEventListener('keydown', (e) => { \r\n        if (e.code === \"Escape\" && modal.classList.contains('show')) { //Закрываем модальное окно по нажатию Esc на клавиатуре только тогда, когда модальное окно открыто.\r\n            //modal.classList.contains('show') - проверяем, есть ли для узла с классом .modal класс .show.\r\n            closeModal();\r\n        }\r\n    });\r\n\r\n    //Вызываем модальное окно через промежуток времени.\r\n    const modalTimerId = setTimeout(openModal, 30000);\r\n\r\n    //Вызываем модальное окно когда страница долистана до конца.\r\n    //Чтобы определить, что пользователь долистал до конца делаем математическую формулу - берём свойство, которое отвечает за прокрутку сверху, затем берём свойство, которое отображает высоту пользовательского окна (видимой части) и будем её сравнивать со scrollHeight,\r\n    //то есть с полной прокруткой и с полным контентом, который есть и если два этих выражения будут совпадать, то значит, что пользователь долистал до конца.\r\n    function showModuleByScroll() {\r\n        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) { //если пользователь долистал до конца\r\n            openModal();\r\n            window.removeEventListener('scroll', showModuleByScroll); // Удаляем обработчик события. Когда пользователь долистывает до конца страницы модальное окно открывается только один раз. \r\n        }\r\n    }\r\n    window.addEventListener('scroll', showModuleByScroll);\r\n}\r\n\r\nmodule.exports = modal;","function slider() {\r\n    /*\r\n    //------------------------------ Слайдер. Вариант №1 -------------------------//\r\n    let slideIndex = 1; //Определяет текущее положение слайда. Изначально №1.\r\n    const slides = document.querySelectorAll('.offer__slide'), //Родительский элемент каждого отдельного слайда.\r\n        prev = document.querySelector('.offer__slider-prev'), //Стрелка влево.\r\n        next = document.querySelector('.offer__slider-next'), //Стрелка вправо.\r\n        total = document.querySelector('#total'), //Номер слайда \"Всего\" 04/#total.\r\n        current = document.querySelector('#current'); //Номер текущего слайда #current/04.\r\n    \r\n    //Инициализируем слайдер. Чтобы он превратился в нужную структуру.\r\n    showSlides(slideIndex);\r\n\r\n    //Определяем общее количество слайдов.\r\n    if (slides.length < 10) { //Если количество элементов .offer__slide меньше 10.\r\n        total.textContent = `0${slides.length}`; //Возвращаем количество слайдов с добавлением 0 и записываем в тег с #total.\r\n    } else {\r\n        total.textContent = slides.length; // Возвращаем количество слайдов, не подставляя 0 вначале и записываем в тег с #total.\r\n    }\r\n\r\n    // Функция по показу и скрытию слайдов.\r\n    function showSlides(n) { //В n приходит slideIndex.\r\n        if (n > slides.length) { //Если номер текущего слайда больше, чем последняя граница, больше чем количество слайдов вообще в слайдере.\r\n            slideIndex = 1; //Устанавливаем номер слайда в 1.\r\n        }\r\n        if (n < 1) { //Если номер текущего слайда меньше, чем передняя граница, меньше чем количество слайдов вообще в слайдере., то\r\n            slideIndex = slides.length; //Устанавливаем номер слайда в последний элемент в слайдерах.\r\n        }\r\n\r\n        slides.forEach((item) => item.style.display = 'none'); //Прописываем для каждого .offer__slide стили display = 'none'.\r\n\r\n        slides[slideIndex - 1].style.display = 'block'; // Берём нужный слайд .offer__slide и показываем его. [slideIndex - 1] - так как счёт с 0 и slides это массив. Для slideIndex прописывыем стили display = 'block'.\r\n        \r\n        //Определяем текущее количество слайдов.\r\n        if (slides.length < 10) { //Если количество элементов .offer__slide меньше 10.\r\n            current.textContent =  `0${slideIndex}`; //Возвращаем текущий слайд slideIndex с добавлением 0 и записываем в тег с #current.\r\n        } else {\r\n            current.textContent =  slideIndex; // Возвращаем текущий слайд, не подставляя 0 вначале и записываем в тег с #current.\r\n        }\r\n    }\r\n\r\n    function plusSlides (n) {\r\n        showSlides(slideIndex += n); //slideIndex увеличен на n. Если +, то прибаляем единицу, если приходит отрицательное значение, то отнимаем единицу. И после этого вызывается функция showSlides с необходимым числом.\r\n    }\r\n\r\n    // Назначаем обработчиков событий на prev и next.\r\n    prev.addEventListener('click', function(){\r\n        plusSlides(-1);\r\n    });\r\n\r\n    next.addEventListener('click', function(){\r\n        plusSlides(1);\r\n    });\r\n    */\r\n\r\n    /*\r\n    //------------------------------ Слайдер-карусель. Вариант №2 -------------------------//\r\n    // Есть большая обёртка .offer__slider-wrapper. Для неё назначим свойство overflow = 'hidden', есть всё, что не подходит под ширину блока .offer__slider-wrapper будет скрыто для пользователя. Следующий блок .offer__slider-inner будет в виде карусели. Он займёт столько места, сколько слайдов в ширину (у нас 4 слайда и блок будет занимать 400% от ширины одного слайда который есть на странице). Когла будем нажимать кнопки \"вперёд\" и \"Назад\" слайды будут передвигаться по отношению к .offer__slider-wrapper (при помощи свойства transform = `translateX(-${offset}px)`).\r\n    \r\n    let offset = 0; //Определяет текущий отступ слайда.\r\n    let slideIndex = 1; //Определяет текущее положение слайда. Изначально №1.\r\n\r\n    const slides = document.querySelectorAll('.offer__slide'), //Родительский элемент каждого отдельного слайда.\r\n        prev = document.querySelector('.offer__slider-prev'), //Стрелка влево.\r\n        next = document.querySelector('.offer__slider-next'), //Стрелка вправо.\r\n        total = document.querySelector('#total'), //Номер слайда \"Всего\" 04/#total.\r\n        current = document.querySelector('#current'), //Номер текущего слайда #current/04.\r\n        slidesWrapper = document.querySelector('.offer__slider-wrapper'), // Обёртка для слайдов (для тега с классом .offer__slider-inner). Родительский элемент всех слайдов.\r\n        width = window.getComputedStyle(slidesWrapper).width, //Метод Window.getComputedStyle() возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать. Получаем ширину width окошка .offer__slider-wrapper, через которое отображаются слайды.\r\n        slidesField = document.querySelector('.offer__slider-inner'); // Обёртка для слайдов (для тега с классом .offer__slide)\r\n\r\n    //Определяем общее количество слайдов.\r\n    if (slides.length < 10) { //Если количество элементов .offer__slide меньше 10.\r\n        total.textContent = `0${slides.length}`; //Возвращаем количество слайдов с добавлением 0 и записываем в тег с #total. Cвойство length объекта, который является экземпляром типа Array , устанавливает или возвращает число элементов этого массива. \r\n        current.textContent =  `0${slideIndex}`;\r\n    } else {\r\n        total.textContent = slides.length; // Возвращаем количество слайдов, не подставляя 0 вначале и записываем в тег с #total.\r\n        current.textContent =  slideIndex;\r\n    }\r\n\r\n    slidesField.style.width = 100 * slides.length + '%'; //Устанавливаем ширину блока .offer__slider-inner в 100%*4слайда = 400%. \r\n    slidesField.style.display = 'flex'; //Устанавливаем все слайды в одну строку.\r\n    slidesField.style.transition = '0.5s all'; //Задержка в 0.5s.\r\n\r\n    slidesWrapper.style.overflow = 'hidden'; //Ограничиваем показ внутри .offer__slider-wrapper.\r\n\r\n    slides.forEach(slide => { //перебираем все .offer__slide (Родительский элемент каждого отдельного слайда).\r\n        slide.style.width = width; //для каждого .offer__slide устанавиваем ширину в window.getComputedStyle(slidesWrapper).width.\r\n    });\r\n\r\n    next.addEventListener('click', () => { //Нажимаем на кнопку \"Вперёд\".\r\n        //Механизм изменения offset и его проверки.\r\n        if (offset == (+width.slice(0, width.length - 2) * (slides.length - 1))) { //Сдвигаем слайд. Если отступ offset равен ширине одного слайда (ширину преобразуем в число и убираем ддва последних символа, например, было '500px', стало 500) * 4слайда, значит долистали до конца и нужно вернуться в самое начало. То есть, если ширина достигла 1950px.\r\n            offset = 0; //Возвращаемся в начало.\r\n        } else {\r\n            offset += +width.slice(0, width.length - 2); //Добавляем смещение +650px. Записываем значение в offset. \r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`; // Обращаемся к .offer__slider-inner. Трансформируем элемент по оси x. Используем знак \"-\" для сдвига в минус. \r\n\r\n        if (slideIndex == slides.length) { //Если текущий слайд равен количеству слайдов на странице всего, то\r\n            slideIndex = 1; //Установить текущий слайд в 1.\r\n        } else {\r\n            slideIndex++; //Иначе добавляем к текущему слайду 1.\r\n        }\r\n\r\n        if (slides.length < 10) { //Если количество слайдов меньше 10\r\n            current.textContent =  `0${slideIndex}`; //Установить текущий слайд в 0+номер текущего слайда в тегах html.\r\n        } else {\r\n            current.textContent =  slideIndex; // Иначе указываем просто текущий слайд в тегах html.\r\n        }\r\n    });\r\n\r\n    prev.addEventListener('click', () => {\r\n        if (offset == 0) {\r\n            offset = +width.slice(0, width.length - 2) * (slides.length - 1); //Устанавливаем в 1950px.\r\n        } else {\r\n            offset -= +width.slice(0, width.length - 2); // offset = offset - +width.slice(0, width.length - 2).\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n        if (slideIndex == 1) { //Если текущий слайд  равен 1, то\r\n            slideIndex = slides.length; //Устанавливаем текущий слайд в количество слайдов \"Всего\".\r\n        } else {\r\n            slideIndex--; //Иначе уменьшаем текущий номер слайда на 1.\r\n        }\r\n\r\n        if (slides.length < 10) { //Если количество слайдов меньше 10, то\r\n            current.textContent =  `0${slideIndex}`; //Указываем в тегах 0+текущйи слайд html.\r\n        } else {\r\n            current.textContent =  slideIndex; //Иначе указываем в тегах номер текущего слайда html.\r\n        }\r\n    });\r\n    */\r\n\r\n    // ---- Слайдер-карусель с точками-слайдами. Вариант №3 ---- //\r\n\r\n    // Получаем, как элемент весь слайдер, включая индикаторы и всё остальное. Устанавливаем position: relative (точки должны быть абсолютно спозиционированы и прикреплены к низу). Затем с помощью цикла необходимо сощдавать количество точек, равное количеству слайдов, чтобы было чёткое соответствие. Каждой точке устанавливается характерный признак(атрибут), для того, чтобы связять конкретную точку с конкретным слайдом. Так же нужно создать класс активности, чтобы чётко понимать какой слайд сейчас активен. При клике на точку, перемещаемся на соответвующий слайд.\r\n    \r\n    let offset = 0; //Определяет текущий отступ слайда.\r\n    let slideIndex = 1; //Определяет текущее положение слайда. Изначально №1.\r\n\r\n    const slides = document.querySelectorAll('.offer__slide'), //Родительский элемент каждого отдельного слайда.\r\n        slider = document.querySelector('.offer__slider'), //Родительский элемен всего слайдера, включая кнопки навигации.\r\n        prev = document.querySelector('.offer__slider-prev'), //Стрелка влево.\r\n        next = document.querySelector('.offer__slider-next'), //Стрелка вправо.\r\n        total = document.querySelector('#total'), //Номер слайда \"Всего\" 04/#total.\r\n        current = document.querySelector('#current'), //Номер текущего слайда #current/04.\r\n        slidesWrapper = document.querySelector('.offer__slider-wrapper'), // Обёртка для слайдов (для тега с классом .offer__slider-inner). Родительский элемент всех слайдов.\r\n        width = window.getComputedStyle(slidesWrapper).width, //Метод Window.getComputedStyle() возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать. Получаем ширину width окошка .offer__slider-wrapper, через которое отображаются слайды.\r\n        slidesField = document.querySelector('.offer__slider-inner'); // Обёртка для слайдов (для тега с классом .offer__slide)\r\n\r\n    //Определяем общее количество слайдов.\r\n    if (slides.length < 10) { //Если количество элементов .offer__slide меньше 10.\r\n        total.textContent = `0${slides.length}`; //Возвращаем количество слайдов с добавлением 0 и записываем в тег с #total. Cвойство length объекта, который является экземпляром типа Array , устанавливает или возвращает число элементов этого массива. \r\n        current.textContent =  `0${slideIndex}`;\r\n    } else {\r\n        total.textContent = slides.length; // Возвращаем количество слайдов, не подставляя 0 вначале и записываем в тег с #total.\r\n        current.textContent =  slideIndex;\r\n    }\r\n\r\n    slidesField.style.width = 100 * slides.length + '%'; //Устанавливаем ширину блока .offer__slider-inner в 100%*4слайда = 400%. \r\n    slidesField.style.display = 'flex'; //Устанавливаем все слайды в одну строку.\r\n    slidesField.style.transition = '0.5s all'; //Задержка в 0.5s.\r\n\r\n    slidesWrapper.style.overflow = 'hidden'; //Ограничиваем показ внутри .offer__slider-wrapper.\r\n\r\n    slides.forEach(slide => { //перебираем все .offer__slide (Родительский элемент каждого отдельного слайда).\r\n        slide.style.width = width; //для каждого .offer__slide устанавиваем ширину в window.getComputedStyle(slidesWrapper).width.\r\n    });\r\n\r\n    slider.style.position = 'relative'; //Устанавливаем для .offer__slider position = 'relative'.\r\n\r\n    //Создаём большую обёртку для всех слайдов и стилизуем её.\r\n    const indicators = document.createElement('ol'), //Блок с точками для слайдов.\r\n          dots = []; //Истинный массив, в котором можем использовать push.\r\n    indicators.classList.add('carousel-indicators'); //Класс для блока с точками для слайдов.\r\n    indicators.style.cssText = `\r\n        position: absolute;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        z-index: 15;\r\n        display: flex;\r\n        justify-content: center;\r\n        margin-right: 15%;\r\n        margin-left: 15%;\r\n        list-style: none;\r\n    `; // Добавляем стили для класса carousel-indicators\r\n    slider.append(indicators); //Помещаем .carousel-indicators внутрь .offer__slider.\r\n\r\n    for (let i = 0; i < slides.length; i++) { //Цикл закончится тогда, когда закончаться сллайды.\r\n        const dot = document.createElement('li'); //Создаём точки (li).\r\n        dot.setAttribute('data-slide-to', i + 1); //Индикатор соответвия, например первая точка ведёт к первому слайду. .setAttribute() - Добавляет новый атрибут или изменяет значение существующего атрибута у выбранного элемента. Каждой токе устанавливаем атрибут data-slide-to, и устанавливаем нумеруацию, начиная с 1.\r\n        dot.style.cssText = `\r\n            box-sizing: content-box;\r\n            flex: 0 1 auto;\r\n            width: 30px;\r\n            height: 6px;\r\n            margin-right: 3px;\r\n            margin-left: 3px;\r\n            cursor: pointer;\r\n            background-color: #fff;\r\n            background-clip: padding-box;\r\n            border-top: 10px solid transparent;\r\n            border-bottom: 10px solid transparent;\r\n            opacity: .5;\r\n            transition: opacity .6s ease;\r\n        `;\r\n        if (i == 0) { //Если итерация первая, то \r\n            dot.style.opacity = 1; //Обращаемся к li и добавляем ему стиль opacity = 1.\r\n        }\r\n        indicators.append(dot); //Добавляем li в ol\r\n        dots.push(dot); //Помещаем li в массив dots. В итоге получаем массив с точками.\r\n    }\r\n\r\n    function deleteNotDigits(str) {\r\n        return +str.replace(/\\D/g, '');\r\n    }\r\n\r\n    next.addEventListener('click', () => { //Нажимаем на кнопку \"Вперёд\".\r\n        //Механизм изменения offset и его проверки.\r\n        //if (offset == (+width.slice(0, width.length - 2) * (slides.length - 1))) { //Сдвигаем слайд. Если отступ offset равен ширине одного слайда (ширину преобразуем в число и убираем ддва последних символа, например, было '500px', стало 500) * 4слайда, значит долистали до конца и нужно вернуться в самое начало. То есть, если ширина достигла 1950px.\r\n\r\n        if (offset == (deleteNotDigits(width) * (slides.length - 1))) { //+width.replace(/\\D/g, '')- все не числа, которые находятся внутри строки удаляем, полученное число умножаем на 4слайда (slides.length - 1).\r\n        \r\n            offset = 0; //Возвращаемся в начало.\r\n        } else {\r\n            offset += deleteNotDigits(width); //Добавляем смещение +650px. Записываем значение в offset. \r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`; // Обращаемся к .offer__slider-inner. Трансформируем элемент по оси x. Используем знак \"-\" для сдвига в минус. \r\n\r\n        if (slideIndex == slides.length) { //Если текущий слайд равен количеству слайдов на странице всего, то\r\n            slideIndex = 1; //Установить текущий слайд в 1.\r\n        } else {\r\n            slideIndex++; //Иначе добавляем к текущему слайду 1.\r\n        }\r\n\r\n        if (slides.length < 10) { //Если количество слайдов меньше 10\r\n            current.textContent =  `0${slideIndex}`; //Установить текущий слайд в 0+номер текущего слайда в тегах html.\r\n        } else {\r\n            current.textContent =  slideIndex; // Иначе указываем просто текущий слайд в тегах html.\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = \".5\"); //Перебираем массив dots. Каждой точке устанавливаем стили в opacity = \".5\".\r\n        dots[slideIndex-1].style.opacity = 1; //Устанавливаем для dots номер текущего слайда - 1 в opacity = 1.\r\n    });\r\n\r\n    prev.addEventListener('click', () => {\r\n        if (offset == 0) {\r\n            offset = deleteNotDigits(width) * (slides.length - 1); //Устанавливаем в 1950px.\r\n        } else {\r\n            offset -= deleteNotDigits(width); // offset = offset - +width.slice(0, width.length - 2).\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n        if (slideIndex == 1) { //Если текущий слайд  равен 1, то\r\n            slideIndex = slides.length; //Устанавливаем текущий слайд в количество слайдов \"Всего\".\r\n        } else {\r\n            slideIndex--; //Иначе уменьшаем текущий номер слайда на 1.\r\n        }\r\n\r\n        if (slides.length < 10) { //Если количество слайдов меньше 10, то\r\n            current.textContent =  `0${slideIndex}`; //Указываем в тегах 0+текущйи слайд html.\r\n        } else {\r\n            current.textContent =  slideIndex; //Иначе указываем в тегах номер текущего слайда html.\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = \".5\"); //Перебираем массив dots. Каждой точке устанавливаем стили в opacity = \".5\".\r\n        dots[slideIndex-1].style.opacity = 1; //Устанавливаем для dots номер текущего слайда - 1 в opacity = 1.\r\n    });\r\n\r\n    dots.forEach(dot => { //Для массива dots, в котором содержатся li.\r\n        dot.addEventListener('click', (e) => { //На каждую точку навешиваем обработчик события клика.\r\n            const slideTo = e.target.getAttribute('data-slide-to'); //Используем объект события. Получаем атрибут data-slide-to.\r\n\r\n            slideIndex = slideTo; //Номер слайда устанавливаем в data-slide-to, то есть кликнули на data-slide-to=4, текущий слайд установился в 1.\r\n            offset = deleteNotDigits(width) * (slideTo - 1); //Берём общую ширину слайда * на номер li (data-slide-to).\r\n\r\n            slidesField.style.transform = `translateX(-${offset}px)`; //Устанавливаем смещение для слайдера.\r\n\r\n            if (slides.length < 10) {\r\n                current.textContent =  `0${slideIndex}`;\r\n            } else {\r\n                current.textContent =  slideIndex;\r\n            }\r\n\r\n            dots.forEach(dot => dot.style.opacity = \".5\"); //Перебираем массив dots. Каждой точке устанавливаем стили в opacity = \".5\".\r\n            dots[slideIndex-1].style.opacity = 1; //Устанавливаем для dots номер текущего слайда - 1 в opacity = 1.\r\n        });\r\n    });\r\n}\r\n\r\nmodule.exports = slider;","function tabs() {\r\n    //--------------------- Переключение контента по нажатию на вкладку Tab --------------//\r\n    const tabs = document.querySelectorAll('.tabheader__item'), //Получаем все вкладки.\r\n          tabsContent = document.querySelectorAll('.tabcontent'), //Получаем весь контентент для вкладок.\r\n          tabsParent = document.querySelector('.tabheader'); //Получаем родитеьский элемент вкладок.\r\n    \r\n    function hideTypeContent() { //Создаём функуию, которая скрывает контент вкладки.\r\n        tabsContent.forEach(item => { // перебираем псевдомасив с .tabcontent\r\n            //item.style.display = 'none'; //скрыть каждый.tabcontent. в реальных проектах не всегда испольуются inline.\r\n            item.classList.add('hide'); //добавляем класс hide, который скрывает контент.\r\n            item.classList.remove('show', 'fade'); //добавляем класс show, который показывает контент,убираем анимацию.\r\n            // toggle использовать нельзя.\r\n        });\r\n        \r\n        tabs.forEach(item => { //Убираем класс активности. Перебираем псевдомасив с .tabheader__item\r\n            item.classList.remove('tabheader__item_active'); //удаляем ...._active найденный в .tabheader__item.\r\n        });\r\n    }\r\n\r\n    function showTypeContent(i = 0) { //Создаём функуию, которая показывает контент вкладки.\r\n        // По умолчанию выводится первый элемент.\r\n        // tabsContent[i].style.display = 'block'; //в реальных проектах не всегда испольуются inline стили.\r\n        tabsContent[i].classList.add('show', 'fade'); //добавляем класс hide, который скрывает контент + анимация.\r\n        tabsContent[i].classList.remove('hide'); //добавляем класс show, который показывает контент.\r\n        tabs[i].classList.add('tabheader__item_active'); //добавляем ...._active найденный в .tabheader__item.\r\n    }\r\n\r\n    hideTypeContent();\r\n    showTypeContent(); //по умолчанию показываем контент первой вкладки.\r\n\r\n    // Делегирование событий и назначаем обработчик событий клика.\r\n    // Когда кликнули в пункт меню определяем его № в списке всех табов и по этому № вызываем функцию showTypeContent(),\r\n    // то есть показываем контент и делается это перебором. Перебераем все табы, и сравниваем,\r\n    // если элемент, который находится в псевдомассиве .tabheader__item совпадает с тем элементом,\r\n    // который кликнул пользователь, тогда мы берём его номер и показываем на странице.\r\n    tabsParent.addEventListener('click', (event) => { //Нажимаем на .tabheader\r\n        const target = event.target;\r\n        if (target && target.classList.contains('tabheader__item')) { //кликнули точно на вкладку.\r\n            tabs.forEach((item, i) => { //перебираем массив с вкладками .tabheader__item.\r\n                if (target == item) { // если .tabheader__item совпадаем с элементом в .forEach, то есть item.\r\n                    hideTypeContent(); //то скрываем весь контент.\r\n                    showTypeContent(i); //показываем тот порядковый элемент i в который кликнули.\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = tabs;","function timer() {\r\n    //------------------------------------- Таймер на сайте -------------------------------//\r\n    // Timer\r\n    const deadline = '2020-07-31'; //Это будет отправная точка. Будущая дата.\r\n    // Делаем функцию, которая определяет разницу между деадлайном и текущим временем.\r\n    function getTimeRemaining(endtime) {\r\n        const t = Date.parse(endtime) - Date.parse(new Date()), //получаем разницу в милисекундах между конечной датой и текущей датой.\r\n        // Метод Date.parse() разбирает строковое представление даты и возвращает количество миллисекунд.\r\n        //Превращаем количество милисекунд в формат Дни/Часы/Минуты/Секунды.\r\n              days = Math.floor(t / (1000 * 60 * 60 * 24)),\r\n        //Подсчитать количество дней, которые будут отображаться в таймере. Делим количество милисекунд на количество милисекунд, которые находятся в одном дне.\r\n        // Количество милисекунд умножаем на 60, получаем милисекунд в одной минуте, дальше снова на 60, получаем милисекунд в часе, умножаем на 24, получаем количество милисекунд в сутках.\r\n        // Делим оставшиеся милисекунды до deadline на количество милисекунд в сутках, полуаем количество суток.\r\n        // Math.floor() - округление до целого числа.\r\n              hours = Math.floor((t / (1000 * 60 * 60) % 24)),\r\n              // (1000 * 60 * 60) - получаем количество милисекунд в часе, t / (1000 * 60 * 60) - получаем оставшееся количество часов, % 24 - делим количество часов на 24 и получаем остаток, таким образом мы получаем число, которое не хватает до полных суток.\r\n              //Например, при делении t / (1000 * 60 * 60) получилось 50 часов. 50 делим на 24, получаем два дня (48), и в остатке два часа.\r\n              minutes = Math.floor((t / 1000 / 60) % 60), //Минуты\r\n              seconds = Math.floor((t / 1000) % 60); //Секунды\r\n\r\n              //Чтобы вывести переменные наружу, используем return\r\n              return { //Возвращаем объект и возвращаем из функции\r\n                'totalMs': t,\r\n                'days': days,\r\n                'hours': hours,\r\n                'minutes': minutes,\r\n                'seconds': seconds,\r\n              };\r\n    }\r\n    // Когда число в таймере однозначное, подставляем вмереди нолик.\r\n    function getZero(num) {\r\n        if (num >= 0 && num < 10) {\r\n            return `0${num}`; //модифицируем, подставляем спереди нолик.\r\n        } else {\r\n            return num; //не модифицируем число.\r\n        }\r\n    }\r\n\r\n    // Устанавливаем таймер на страницу.\r\n    function setClock(selector, endtime) {\r\n        //Помещаем элементы со страницы\r\n        const timer = document.querySelector(selector), //получаем корневой ээлемент таймера .timer\r\n              days = timer.querySelector('#days'), // поучаем #days внутри .timer\r\n              hours = timer.querySelector('#hours'),\r\n              minutes = timer.querySelector('#minutes'),\r\n              seconds = timer.querySelector('#seconds');\r\n        updateClock(); //Указываем здесь, чтобы убрать мигание таймера при обновлении страницы. Нужно, когда const timeInterval = setInterval(updateClock, 1000); указана выше самой функции обновления.\r\n        //Обновляем таймер каждую секунду.\r\n        function updateClock() {\r\n            const t = getTimeRemaining(endtime); //Расчёт времени, который остался на текущую секунду. Это дедлай, который передаётся в setClock. Получаем объект с набором интересующих нас свойств.\r\n            //Помещаем расчётные величины на страницу.\r\n            days.innerHTML = getZero(t.days); //берём количество дней, котрое нужно отобразить на странице. getZero() - модифицирует число.\r\n            hours.innerHTML = getZero(t.hours);\r\n            minutes.innerHTML = getZero(t.minutes);\r\n            seconds.innerHTML = getZero(t.seconds);\r\n            //Когда функция запустится, она расчитает нужно время и на основании этих расчётов она бедут записывать на страницу все эти результаты.\r\n            //Запускаем функцию каждую секунду.\r\n            const timeInterval = setInterval(updateClock, 1000); //Запуск функции через определённый промежуток времени.\r\n            //Останавливаем таймер\r\n            if (t.totalMs <= 0) { //если разница между текущим временем и деадлайном меньше или равно 0,\r\n                clearInterval(timeInterval); //то перестаём обновлять таймер.\r\n            }\r\n        }\r\n        updateClock();\r\n    }\r\n    //вызываем все функции\r\n    setClock('.timer', deadline);\r\n}\r\n\r\nmodule.exports = timer;","'use strict';\nwindow.addEventListener('DOMContentLoaded', () => { //Загружаем DOM структуру.\n    //Импортируем все модульные файлы в текущий.\n    const cacl = require('./modules/cacl'),\n          cards = require('./modules/cards'),\n          forms = require('./modules/forms'),\n          modal = require('./modules/modal'),\n          slider = require('./modules/slider'),\n          tabs = require('./modules/tabs'),\n          timer = require('./modules/timer');\n    \n    cacl();\n    cards();\n    modal();\n    forms();\n    slider();\n    tabs();\n    timer();\n});\n\n\n\n"],"sourceRoot":""}