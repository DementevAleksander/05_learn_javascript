'use strict';
// --- Свойства - геттеры и сеттеры ---- //
// Есть два типа свойств объекта.
// Первый тип это свойства-данные (data properties). Мы уже знаем, как работать с ними. Все свойства, которые мы использовали до текущего момента, были свойствами-данными.
// Второй тип свойств мы ещё не рассматривали. Это свойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

const persone = {
    name: 'Alex',
    age: 25,
    get userAge() { //Получаем значение.
        return this.age;
    },
    set userAge(num) { //Отправляем данные.
        this.age = num;
    }
};

console.log(persone.userAge); //В консоле 25.
console.log(persone.userAge = 30); //В консоле 30.
console.log(persone.userAge); //В консоле 30.


// --- Инкапсуляция ---- //
// Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. В объектно-ориентированном программировании код и данные могут быть объединены вместе; в этом случае говорят, что создаётся так называемый "чёрный ящик". Когда коды и данные объединяются таким способом, создаётся объект (object). Другими словами, объект - это то, что поддерживает инкапсуляцию.
// Внутри объекта коды и данные могут быть закрытыми (private). Закрытые коды или данные доступны только для других частей этого объекта. Таким образом, закрытые коды и данные недоступны для тех частей программы, которые существуют вне объекта. Если коды и данные являются открытыми, то, несмотря на то, что они заданы внутри объекта, они доступны и для других частей программы. Характерной является ситуация, когда открытая часть объекта используется для того, чтобы обеспечить контролируемый интерфейс закрытых элементов объекта.
// На самом деле объект является переменной определённого пользователем типа. Может показаться странным, что объект, который объединяет коды и данные, можно рассматривать как переменную. Однако применительно к объектно-ориентированному программированию это именно так. Каждый элемент данных такого типа является составной переменной.

//На примере функции-конструкторе.
function User(name, age) { //Конструируем новый объект.
    this.name = name; //Свойство имя.
    this.age = age; //Свойство возраст.

    this.say = function () { //метод say
        console.log(`Имя пользователя ${this.name}, возраст ${this.age} !`);
    };
}
const nameUser = new User('Саня', 31);

//Получаем свойства.
console.log(nameUser.name); //В консоле Саня.
console.log(nameUser.age); //В консоле 31.

//Изменяем свойства.
nameUser.name = 'Nastya';
nameUser.age = 32;

nameUser.say(); //В консоле Имя пользователя Nastya, возраст 32 !

// Чтобы не было вмешшателства, необходимо использовать инкапсуляцию.
function UserNew(name, age) { //Конструируем новый объект.
    this.name = name; //Свойство имя.
    let userAge = age; //Свойство возраст.

    this.say2 = function () { //метод say
        console.log(`Имя пользователя ${this.name}, возраст ${userAge} !`);
    };

    //Создаём два метода, которые будут работать с userAge снаружи. Один мтод будет отдавать значение, второй будет это значение изменять.
    //Получаем возраст.
    this.getAge = function () {
        return userAge;
    };

    //Меняем значение возраста.
    this.setAge = function (age) {
        //Проверяем, что в функцию пришло число.
        if (typeof age === 'number' && age > 0 && age < 150) {
            userAge = age;
        } else {
            console.log('Недопустимое значение!');
        }

    };

}
const nameUser2 = new UserNew('Саня', 31);

//Получаем свойства.
console.log(nameUser2.name); //В консоле Саня.
console.log(nameUser2.userAge); //В консоле undefined. Не можем получить, так как она спрятана внутри функции, как переменная. .userAge в данном случае не свойство объекта.

//Изменяем свойства.
nameUser2.name = 'Nastya';
nameUser2.userAge = 32;

nameUser2.say2(); //В консоле Имя пользователя Nastya, возраст 31 ! То есть возраст не поменялся.

console.log(nameUser2.getAge()); //Получаем возраст. В консоле 31.
nameUser2.setAge(50); //Изменяем возраст.
console.log(nameUser2.getAge()); //Получаем возраст. В консоле 50. То есть внутрь UserNew() записали новое значение возраста, которое стало 50.
nameUser2.setAge(500); //Изменяем возраст. В консоле выводится "Недопустимое значение!", так как значение не попадает под условия.
console.log(nameUser2.getAge()); //Получаем возраст. То есть в консоле осталось предыдущее перезаписанное значение 50.
nameUser2.say2(); //В консоле "Имя пользователя Nastya, возраст 50 !", то есть возраст поменялся.


// Инкапсуляция на классах.
class UserNew2 {
    constructor(name, age) {
        this.name = name;
        this._age = age; //._age - скрытое свойство. Это не синтаксис языка. Соглашение между разработчиками. Мы не вмешиваемся в работу этого свойства.
    }

    // #surname = 'Brukbond'; // Приватное свойство. Данный синтаксис экспериментальный и ещё не входит в стандарт ES6. Позволяет создавать свойства класса вне конструктора. Свойство, которое записывается точно так же в объект, только без конструктора. Это удобно, когда нужно записать свойства, которые не будут меняться вне зависимости от аргументов, которые пришли в наш класс.

    // say = () => {
    //     console.log(`Имя пользователя: ${this.name} ${this.#surname}, возраст ${this._age}`);
    // } //Методы, написанные в классах моно задавать в качестве стредочных функций, чтобы не терять контекст. Главная особенность, что контекст вызова this всегда будет ссылаться на экземаляр этого объекта.

    say() {
        console.log(`Имя пользователя: ${this.name}, возраст ${this._age}`);
    }

    get age() {
        return this._age;
    }

    set age(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('Недопустимое значение!');
        }
    }
}

const ivan = new UserNew2('Ivan', 27);
console.log(ivan.age); //Используем .age, а не ._age. ._age - использовать нельзя. В консоле 27.
ivan.age = 99;
console.log(ivan.age); //В консоле 99.
ivan.say(); //В консоле "Имя пользователя: Ivan, возраст 99".

