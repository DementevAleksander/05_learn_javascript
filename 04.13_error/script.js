'use strict';
//Обработка ошибок.
try { //Сначала считывается код внутри try. Если всё выполнилось нормально, то участок кода catch(){} игнорируется. Но если возникает какая-либо ошибка, то перемещаемся в блок кода catch(){}.
    console.log('Привет от try!');
    console.log(a);
    console.log('Код, после несуществующей переменной!');
} catch(error) { //Выполняется в случае ошибки в try{}.
    console.log('Ошибка от catch!');
    console.log(error.name);
    console.log(error.message);
    console.log(error.stack);
} finally { //Выполняется абсолютно всегда.
    console.log('Код, который всегда выполняется finally!');
}
//Код написанный после конструкции try/catch продолжит работать, вне зависимости была ли ошибка в конструкции.
console.log('Код продолжился!');
// В консоле:
// Привет от try!
// Ошибка от catch!
// ReferenceError
// a is not defined
// ReferenceError: a is not defined
//     ............
// Код, который всегда выполняется finally!
// Код продолжился!

// Если же была бы такая конструкция, то код не выполнялся бы.
// console.log('Привет от try!');
// console.log(a);
// console.log('Код продолжился!'); //Эта часть не отработала бы.

//Данная конструкция удобна, к примеру, для много страничных сайтов. Например, на обной странице есть елемент, на который повешен обработчик события, на другой странице такого элемента нет, соответсвенно будет выводиться ошибка.
//Пример.
try {
    document.querySelector('.active').addEventListener('click', ()=> {
        console.log('Click!');
    });
} catch(error) {
    console.log(error); //Можно ничего не указывать.
}
console.log('normal!');